
; --- lab4spel.asm

	.equ	VMEM_SZ     = 5		; #rows on display
	.equ	AD_CHAN_X   = 3		; ADC0=PA0, PORTA bit 0 X-led
	.equ	AD_CHAN_Y   = 4		; ADC1=PA1, PORTA bit 1 Y-led
	.equ	GAME_SPEED  = 70	; inter-run delay (millisecs)
	.equ	PRESCALE    = 7		; AD-prescaler value ------ är till för att A/D omvandlaren inte ska gå för fort
	.equ	BEEP_PITCH  = 200	; Victory beep pitch
	.equ	BEEP_LENGTH = 5	; Victory beep length
	
	; ---------------------------------------
	; --- Memory layout in SRAM
	.dseg
	.org	SRAM_START            ; ----------------------- allt detta sparas i SRAM
POSX:	.byte	1	; Own position    --- styrs av joystick
POSY:	.byte 	1                          ;  --- styrs av joystick
TPOSX:	.byte	1	; Target position   ---  ligger redan i SRAM minnet efter initisering 
TPOSY:	.byte	1
LINE:	.byte	1	; Current line	-------------------- själva muxningen
VMEM:	.byte	VMEM_SZ ; Video MEMory -------------------- innehåller båda punkter som ska lysa, 5 byte stor "5rader"
SEED:	.byte	1	; Seed for Random  ---------------------  något som ska kunna bli ett slumptal

	; ---------------------------------------
	                                                    ; --- Macros for inc/dec-rementing
	                                                    ; --- a byte in SRAM
	.macro INCSRAM	; inc byte in SRAM
		lds	r16,@0
		inc	r16
		sts	@0,r16
	.endmacro

	.macro DECSRAM	; dec byte in SRAM
		lds	r16,@0
		dec	r16
		sts	@0,r16
	.endmacro

	; ---------------------------------------
	; --- Code
	.cseg
	.org 	$0
	jmp	START
	.org	INT0addr
	jmp	MUX


START:
;	***			; sätt stackpekaren						-------------SKA VARA OK!
	ldi	r16, HIGH(RAMEND)
	out	SPH, r16
	ldi	r16, LOW(RAMEND)
	out	SPL, r16
	
	clr r24
	clr r25 ; DELAY
	clr r3

	clr r16

	call	HW_INIT								;----------- SKA VARA OK!
	call	WARM								;----------- SKA VARA OK!
RUN:
	call	JOYSTICK
	;cli
	call	ERASE_VMEM
	;sei
	call	UPDATE

;*** 	Vänta en stund så inte spelet går för fort 	***
	
	call DELAY									; --------DELAY rutinen är inte gjord ännu, ligger längst ner

;*** 	Avgör om träff				 	*** --------- om posx,posy = tpox,tposy är lika
	push r16
	push r17
	lds r16, POSX
	lds r17, TPOSX
	cp r16,r17
	brne	NO_HIT	; om ingen träff gå hit
HIT:
	lds r16, POSY
	lds r17, TPOSY
	cp r16, r17
	brne NO_HIT
	ldi	r16,BEEP_LENGTH ; annars ladda med tonlängd
	call	BEEP ; ge ut en ton
	pop r17
	pop r16
	call	WARM ; kör om programmet/ ladda det igen
	

DELAY:
	push r24
	push r25
	push r16
	in r16,SREG
LOOP:
	sbiw r24,1
	brne LOOP
	out SREG,r16
	pop r16
	pop r25
	pop r24
	ret
NO_HIT:   
	pop r17
	pop r16                                             ;--------- om posx,posy =/ tpox,tposy
	jmp	RUN

	; ---------------------------------------
	; --- Multiplex display
MUX:	

;*** 	skriv rutin som handhar multiplexningen och ***
;*** 	utskriften till diodmatrisen. Öka SEED.		*** 

	push r16; Y
	push r17; X
	push r18
	push YL
	push YH
	in r18,SREG

	lds r16,LINE
	cpi r16,5
	brne PRINT
RESET_LINE:
	clr r16
PRINT:
	add YL,r16
	adc YH,r3

	clr r17
	out PORTB,r17
	out PORTA,r16
	ld r17,Y
	out PORTB,r17
	inc r16
	sts LINE,r16

	lds r16,SEED
	inc r16
	sts SEED,r16

	out SREG,r18
	pop YH
	pop YL
	pop r18
	pop r17
	pop r16
	reti
	

	; ---------------------------------------
	; --- JOYSTICK Sense stick and update POSX, POSY
	; --- Uses r16


INPUT:
	;ADC	
	out ADMUX,r16
	;ADC setup
	ldi r16,(1<<ADEN)|(1<<ADSC)
	out ADCSRA,r16
WAIT:
	sbic ADCSRA,ADSC
	rjmp WAIT
	
	in r16,ADCH
	ret


INPUTX:
	push r16
	push r17
	in r17,SREG

	ldi r16,AD_CHAN_X
	rcall INPUT
	cpi r16,0
	brne CHECK_3 
	DECSRAM POSX
	rjmp X_DONE

CHECK_3:
	cpi r16,3
	brne X_DONE
	INCSRAM POSX
X_DONE:
	out SREG,r17
	pop r17
	pop r16
	ret

INPUTY:
	push r16
	push r17
	in r17,SREG

	ldi r16,AD_CHAN_Y
	rcall INPUT
	cpi r16,0
	brne CHECK_Y_3
	DECSRAM POSY
	rjmp Y_DONE
CHECK_Y_3:
	cpi r16,3
	brne Y_DONE
	INCSRAM POSY
Y_DONE:
	out SREG,r17
	pop r17
	pop r16
	ret
	; ---------------------------------------
	; --- JOYSTICK Sense stick and update POSX, POSY
	; --- Uses r16
JOYSTICK:	

;*** 	skriv kod som ökar eller minskar POSX beroende 	***
;*** 	på insignalen från A/D-omvandlaren i X-led...	***


	rcall INPUTX

;*** 	...och samma för Y-led 				***
	rcall INPUTY
	



JOY_LIM:
	call	LIMITS		; don't fall off world!
	ret

	; ---------------------------------------
	; --- LIMITS Limit POSX,POSY coordinates	
	; --- Uses r16,r17
LIMITS:
	lds	r16,POSX	; variable
	ldi	r17,7		; upper limit+1
	call	POS_LIM		; actual work
	sts	POSX,r16
	lds	r16,POSY	; variable
	ldi	r17,5		; upper limit+1
	call	POS_LIM		; actual work
	sts	POSY,r16
	ret

POS_LIM:
	ori	r16,0		; negative?
	brmi	POS_LESS	; POSX neg => add 1
	cp	r16,r17		; past edge
	brne	POS_OK
	subi	r16,2
POS_LESS:
	inc	r16	
POS_OK:
	ret

	; ---------------------------------------
	; --- UPDATE VMEM
	; --- with POSX/Y, TPOSX/Y
	; --- Uses r16, r17
UPDATE:	
	clr	ZH 
	ldi	ZL,LOW(POSX)
	call 	SETPOS
	clr	ZH
	ldi	ZL,LOW(TPOSX)
	call	SETPOS
	ret

	; --- SETPOS Set bit pattern of r16 into *Z
	; --- Uses r16, r17
	; --- 1st call Z points to POSX at entry and POSY at exit
	; --- 2nd call Z points to TPOSX at entry and TPOSY at exit
SETPOS:

	ld	r17,Z+  	; r17=POSX
	call	SETBIT		; r16=bitpattern for VMEM+POSY
	ld	r17,Z		; r17=POSY Z to POSY
	ldi	ZL,LOW(VMEM)
	add	ZL,r17		; *(VMEM+T/POSY) ZL=VMEM+0..4
	ld	r17,Z		; current line in VMEM
	or	r17,r16		; OR on place
	st	Z,r17		; put back into VMEM
	ret
	
	; --- SETBIT Set bit r17 on r16
	; --- Uses r16, r17
SETBIT:
	ldi	r16,$01		; bit to shift
SETBIT_LOOP:
	dec 	r17			
	brmi 	SETBIT_END	; til done
	lsl 	r16		; shift
	jmp 	SETBIT_LOOP
SETBIT_END:
	ret

	; ---------------------------------------
	; --- Hardware init
	; --- Uses r16
HW_INIT:                                                               ;---------------------------- RUTINEN SKA VARA OK!

;*** 	Konfigurera hårdvara och MUX-avbrott enligt ***
;*** 	ditt elektriska schema. Konfigurera 		***
;*** 	flanktriggat avbrott på INT0 (PD2).			***                  
	
	ldi r16,(1<<INT0) ; sätt INT0 till Enable
	out GICR,r16
	
	ldi r16,(1<<ISC01)|(0<<ISC00) ; fallande flank skapar ett interupt, man kan även välja "1 1" här för stigande flank
	out MCUCR,r16
	
	ldi r16, $FF
	out DDRB,r16 ; Dessa utportar ska gå till kolumnerna i displayenheten, dvs till pinne 1 -> 7

	ldi r16,$27 ; Vi ska använda 3 utportar som ska skicka en utsignal (vardera) till pinne A,B,C på displayenheten 
	out DDRA,r16 ; sätter utsignalerna från portA

	
	ret

	; ---------------------------------------
	; --- WARM start. Set up a new game
SET_Y_POINTER:
	ldi YL,LOW(VMEM)
	ldi YH,HIGH(VMEM)
	ret
WARM:   
	cli
	rcall SET_Y_POINTER
	rcall	ERASE_VMEM
;*** 	Sätt startposition (POSX,POSY)=(0,2)		***
	
	sts LINE,r3

	clr r16
	sts POSX,r16
	ldi r16,3
	sts POSY,r16

	;push	r16		
	;push	r16		
	
	rcall	RANDOM		; RANDOM returns x,y on stack
	;*** 	Sätt startposition (TPOSX,POSY)***	
	;pop r16
	;sts TPOSX,r16
	;pop r16
	;sts TPOSY,r16


	sei
	ret

RANDOM:                                              				;-----------------------RUTINEN SKA VARA OK!
	in	r16,SPH
	mov	ZH,r16
	in	r16,SPL
	mov	ZL,r16
	lds	r16,SEED
	
;*** 	Använd SEED för att beräkna TPOSX		***      SEED: 0 -255
;*** 	Använd SEED för att beräkna TPOSX		***      ANDI r16,7 
                                                      ;   >4? : subtrahera 4
															
	clr r17
	andi r16,$07
	push r16
	
/* kontrollera om SEED > 4 */

LOOP_SEED: 									;-----------------------RUTINEN SKA VARA OK!
	inc r17
	dec r16	
	cpi r17,$05 ; >4
	breq SIZE_EXCEPTION	
	cpi r16,$00 ; <=4
	breq SIZE_OK

	rjmp LOOP_SEED
	
/* om >4 dvs ligger utanför i Y-led */

SIZE_EXCEPTION:									;-----------------------RUTINEN SKA VARA OK!
	pop r16
	subi r16,$04 ; >4 -> subtrahera 4 från r16 
	rjmp STORE_TPOS 

SIZE_OK:									;-----------------------RUTINEN SKA VARA OK!
	pop r16 
	rjmp STORE_TPOS 
;	***		; store TPOSX	2..6  --------------- borde det inte vara 4 -> 6? om man ska spara TPOS i vänstra planhalvan?
;	***		; store TPOSY   0..4                 -------------- Vi ska alltså använda stacken, se sidan 71 föreläsningsPDF
STORE_TPOS:									;-----------------------RUTINEN SKA VARA OK!
	sts TPOSY,r16
	inc r17          ; ------------- lite kul, men counter kommer minst vara 1 och max 5, eller allt där emellan. 
	sts TPOSX,r17    ; ------------- så öka med 1 så får vi random nummer mellan 2 -> 6
	
ret


	; ---------------------------------------
	; --- Erase Videomemory bytes
	; --- Clears VMEM..VMEM+4

ERASE_VMEM:                                                                ;-----------------------RUTINEN SKA VARA OK!

;*** 	Radera videominnet						***
	push ZL
	push ZH
	
	clr r16
	ldi r17,$05
	ldi ZL,LOW(VMEM)  ;-------------------------------------------  Kan vara att den här är onödig, får se längre fram i koden vad Z laddas med
	ldi ZH,HIGH(VMEM) 
	
LOOP_VMEM:									;-----------------------RUTINEN SKA VARA OK!

	dec r17 ; 5,4,..,0. VMEM är 5 bitar stort!
	st Z+,r16 ; går genom alla 5 bitar i VMEM
	cpi r17,$00
	breq VMEM_ERASED
	rjmp LOOP_VMEM

VMEM_ERASED:									;-----------------------RUTINEN SKA VARA OK!
	
	pop ZH
	pop ZL
	ret

	; ---------------------------------------
	; --- BEEP(r16) r16 half cycles of BEEP-PITCH
BEEP:	
	cli
;*** skriv kod för ett ljud som ska markera träff 	***
	push r16
	;ldi	r16,BEEP_LENGTH

BEEP_LOOP:
	sbi	PORTA,5 ;kan vara att den här delen strular, set bit in I/O reg A. Ett ljud ges ut när porten clearas -> går till låg spänning
	call	DELAY
	cbi	PORTA, 5 ; clear bit in I/0 reg B. Om det inte fungerar så testar vi att sätta de på samma port. helst portA7 i så fall
	call	DELAY
	dec	r16
	brne	BEEP_LOOP
	pop r16
	sei
	ret
;------------------------------------------------